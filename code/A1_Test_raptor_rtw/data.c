/*****************************************************************************
   data.c
   Generated By:
   Raptor 2021b_2.0.14465 (6183)
   Matlab (R2021b) 9.11

   Copyright (c) 2018 New Eagle Products, Inc.
   All rights reserved.

   Code Generated at: Sun Jan  1 18:42:51 2023
 *****************************************************************************/

#include "raptor_types.h"
#include "data.h"
#include "string.h"                    /* TODO Reseach availabilty */
#include "A1_Test.h"
#include "A1_Test_private.h"
#include "mem_api.h"
#include "sdk_crc.h"

/* SS_DOUBLE  =  0,    / real32_T    /
   SS_SINGLE  =  1,    / real32_T  /
   SS_INT8    =  2,    / int8_T    /
   SS_UINT8   =  3,    / uint8_T   /
   SS_INT16   =  4,    / int16_T   /
   SS_UINT16  =  5,    / uint16_T  /
   SS_INT32   =  6,    / int32_T   /
   SS_UINT32  =  7,    / uint32_T  /
   SS_BOOLEAN =  8     / boolean_T */
RAMVariables_T RAMVariables __attribute__ ((section (".ramsymbols")));
const RAMVariables_T RAMVariables_DEFAULT __attribute__ ((section (".romsymbols")))
  = {
  55,                                  /*INIT_RAM_Variables*/
  0,                                   /* FgndTasksStopped */
  0,                                   /* KeySw_Bgnd */
  0,                                   /* KeepModuleOn */
  0,                                   /* TTC */
  0,                                   /* RR_new */
  0,                                   /* Jx_HV_mps3 */
  0,                                   /* TH */
  0,                                   /* Acc_Mode */
  0,                                   /* Driving_Torque */
  0,                                   /* Braking_Pressure_RR */
  0,                                   /* VACCTargetVehAssigned_flg */
  0,                                   /* RR_est */
  0,                                   /* RV_est */
  0,                                   /* RA_est */
  0,                                   /* cut_in_flg */
  0,                                   /* RAx */
  0,                                   /* RVx */
  0,                                   /* RR */
  0,                                   /* Jy_HV_mps3 */
  0,                                   /* C0 */
  0,                                   /* SW_Dynematic */
  0,                                   /* latched */
  0,                                   /* Driving_Torque_b */
  0,                                   /* axc */
  0,                                   /* TH_acc */
  0,                                   /* Desired_distance */
  0,                                   /* Spd_acc */
  11UL,                                /* EcuAddr_RAM */
  1536UL,                              /* UDSServerAddr_RAM */
  1616UL,                              /* UDSClientAddr_RAM */
  0U,                                  /* EEPROM_State */
};

void initRAMVariables(RAMVariables_T* ramVariables)
{
  memcpy(ramVariables, &RAMVariables_DEFAULT, sizeof(RAMVariables_DEFAULT));
}

const CONSTVariables_T CONSTVariables __attribute__ ((section (".romsymbols"))) =
{
  { 65U, 49U, 95U, 84U, 101U, 115U, 116U, },/* ModelName */
  83UL,                                /* BuildNumber */

  { 40U, 82U, 50U, 48U, 50U, 49U, 98U, 41U, 32U, 57U, 46U, 49U, 49U, },/* MatlabVersion */

  { 50U, 48U, 50U, 49U, 98U, 95U, 50U, 46U, 48U, 46U, 49U, 52U, 52U, 54U, 53U,
    95U, 54U, 49U, 56U, 51U, },        /* RaptorVersion */

  { 65U, 49U, 95U, 84U, 101U, 115U, 116U, 95U, 48U, 56U, 51U, },/* SwIdTxt */

  { 65U, 49U, 95U, 84U, 101U, 115U, 116U, 95U, 48U, 56U, 51U, 95U, 48U, 48U, 48U,
  },                                   /* CalIdTxt */

  { 52U, 56U, 75U, 52U, 54U, 68U, 115U, 87U, 73U, 85U, 109U, 87U, 86U, 57U, 89U,
    105U, 105U, 112U, 121U, 51U, 50U, },/* BuildUID */
  4,                                   /* IdTableRev */
  18874880UL,                          /* HardwareType */

  { 48U, 49U, 45U, 74U, 97U, 110U, 45U, 50U, 48U, 50U, 51U, 32U, 49U, 56U, 58U,
    52U, 50U, 58U, 53U, 50U, },        /* DateStamp */
};

void initCONSTVariables(const CONSTVariables_T* cv)
{

#ifdef UNUSED

  UNUSED(cv);

#endif

}

/* Total EEPROM Structure Size: 101U Bytes */
const EEVariables_T EEVariables_DEFAULT = {
  2705335924U,                         /* EE_UniqID 	*/
  0.2F,                                /* KeySwHiTimeThr */
  0.2F,                                /* KeySwLoTimeThr */
  0.0F,                                /* UseTTC_switch */
  60.0F,                               /* ACCSetSpeed_kph */
  0.0F,                                /* Est_switch */
  1.0F,                                /* OnlyPY_signal */
  1.0F,                                /* Cut_in_Secenary_flg */
  0.0F,                                /* Kalman_trig */
  1.0F,                                /* Long_trig */
  1.0F,                                /* Q_th */
  0.1F,                                /* R_th */
  1.0F,                                /* Q_acc */
  0.2F,                                /* R_acc */
  3.0F,                                /* Path_selector */
  10.0F,                               /* V */
  1U,                                  /* Lat_trig */
  0.01F,                               /* Q_D */
  0.5F,                                /* R_D */
  0.25F,                               /* Q_K */
  0.5F,                                /* R_K */
  1.0F,                                /* LaneAvail_flg */
  256UL,                               /* CAN1__XCP_BC_ID */
  512UL,                               /* CAN1__XCP_RX_ID */
  768UL,                               /* CAN1__XCP_TX_ID */
  20037U,                              /* CAN1__XCP_Security */
  0,                                   /* CRC Initial Value */
};

EEVariables_T EEVariables_RAMShadow __attribute__ ((section (".ramsymbols"))) ;
uint16_T read_eeprom(void);
void App_EE_Write(void);

/* MANAGE EE PROM MEMORY */
void App_EE_Defaults(void)
{
  memcpy(&EEVariables_RAMShadow, &EEVariables_DEFAULT, sizeof(EEVariables_T));
  EEPROM_State_Data() = EE_LOADED_DEFAULTS;
}

void App_EE_Init(void);
void App_EE_Init(void)
{
  uint16_t ret = 0;
  uint8_T firstStart = 0;
  uint32_T ee_size = ((uint32_T)&EEVariables_RAMShadow.CRC - (uint32_T)
                      &EEVariables_RAMShadow);
  ret = open_eeprom();
  if (ret != 0x0) {
    EEPROM_State_Data() = EE_LOADED_DEFAULTS_FAILED_DRV_INIT;
    App_EE_Defaults();
    firstStart = 1;
  }

  /* Read and Determine if it is first start after program */
  firstStart = eepage0.FirstStartFlag;

  /* page0 write will be delayed until the proper shut-down store of NV */
  if (firstStart) {
    /* Load defaults after programming - new values may have been merged into EEVariables_DEFAULT */
    App_EE_Defaults();
    EEPROM_State_Data() = EE_LOADED_DEFAULTS_AFTER_PROGRAMMING;
  } else if (read_eeprom() != EE_NO_ERROR) {
    /* Revert to defaults - error reading stored data */
    App_EE_Defaults();
    EEPROM_State_Data() = EE_LOADED_DEFAULTS_ERROR_READING;
  } else if (EEVariables_RAMShadow.EE_UniqID != EEVariables_DEFAULT.EE_UniqID) {
    /* Revert to defaults - the data stored previously doesn't match the format for the current application */
    App_EE_Defaults();
    EEPROM_State_Data() = EE_LOADED_DEFAULTS_INCORRECT_EEID;
  } else if (!is_crc_valid((void*)&EEVariables_RAMShadow, ee_size,
              EEVariables_RAMShadow.CRC)) {
    /* Revert to defaults - stored data is corrupted */
    App_EE_Defaults();
    EEPROM_State_Data() = EE_LOADED_DEFAULTS_INCORRECT_CRC;
  } else {
    /* Normal case startup, reloaded values */
    EEPROM_State_Data() = EE_LOADED_SAVED_VALUES;
                                      /* Normal case startup, reloaded values */
  }
}

uint16_T read_eeprom(void)
{
  uint16_t result;
  uint16_T eeReadIdx = 0;
  uint8_T readBuf[120];
  uint8_T retryCnt = 0;
  uint8_T* wrPtr = (uint8_T*)&EEVariables_RAMShadow;
  uint32_T ee_size = ((uint32_T)&EEVariables_RAMShadow.CRC - (uint32_T)
                      &EEVariables_RAMShadow) + 2;
  uint16_T total_EE_PgCnt = (ee_size / EE_PAGE_SIZE) + ((ee_size % EE_PAGE_SIZE)
    > 0);

  /* READ Full EEPROM */
  for (eeReadIdx = 0; eeReadIdx < total_EE_PgCnt; eeReadIdx++) {
    retryCnt = 0;
    for (retryCnt = 0; retryCnt < 25; retryCnt++) {
      result = ee_read_page(eeReadIdx+1, (void*)&readBuf, EE_PAGE_SIZE);
      if (result == EE_NO_ERROR) {
        break;
      }
    }

    if (result == EE_NO_ERROR) {
      /* copy into EEVariables_RAMShadow	*/
      uint16_T lastFullpageIndx = ((sizeof(EEVariables_T) % EE_PAGE_SIZE) > 0) ?
        (total_EE_PgCnt-1) : total_EE_PgCnt;
      if (eeReadIdx < lastFullpageIndx) {
        memcpy(wrPtr, &readBuf, EE_PAGE_SIZE);
        wrPtr += EE_PAGE_SIZE;
      } else {
        memcpy(wrPtr, &readBuf, sizeof(EEVariables_T) % EE_PAGE_SIZE);
      }
    } else {
      break;
    }
  }

  return result;
}

void App_EE_Store(void)
{
  if (EEPROM_State_Data() != EE_STORE_IN_PROGESS) {
    EEPROM_State_Data() = EE_STORE_IN_PROGESS;
    App_EE_Write();
  }
}

void App_EE_Write(void)
{
  uint16_t result;
  uint32_T ee_size = ((uint32_T)&EEVariables_RAMShadow.CRC - (uint32_T)
                      &EEVariables_RAMShadow) + 2;
  uint16_T total_EE_PgCnt = (ee_size / EE_PAGE_SIZE) + ((ee_size % EE_PAGE_SIZE)
    > 0);
  static uint8_T* eeWrite_Ptr;
  static uint16_T eeWrite_Idx = 0;
  static uint16_T runningCRC = 0xFFFF;
  uint32_T ee_WriteLen = (ee_size < EE_PAGE_SIZE) ? EE_PAGE_SIZE : ee_size;
  runningCRC = crc16_calculation((void*)&EEVariables_RAMShadow, ee_size - 2,
    0xFFFF);
  EEVariables_RAMShadow.CRC = runningCRC;
  eeWrite_Idx = 0;
  eeWrite_Ptr = (void*)&EEVariables_RAMShadow;
  EEPROM_State_Data() = EE_STORE_IN_PROGESS;

  /* Write the set of pages */
  for (eeWrite_Idx = 0; eeWrite_Idx < total_EE_PgCnt; eeWrite_Idx++) {
    /* write page */
    result = ee_write_page(eeWrite_Idx+1,(void*)eeWrite_Ptr, ee_WriteLen);
    if (result == EE_NO_ERROR) {
      /* Success */
      eeWrite_Ptr += EE_PAGE_SIZE;
      if (eeWrite_Idx == (total_EE_PgCnt-1)) {
        /* last page, update crc */
        ee_WriteLen = ee_size % EE_PAGE_SIZE;
        if (ee_WriteLen == 0) {
          ee_WriteLen = ee_size;
        }
      }
    } else {
      break;
      EEPROM_State_Data() = EE_STORE_FAILED;
    }
  }

  {
    boolean test = is_crc_valid((void*)&EEVariables_RAMShadow, ee_size-2,
      runningCRC );
    if (test) {
      uint32_t cnt = 0;
      while (cnt < 15000) {
        cnt++;
      }
    }
  }

  /* finished */
  if (eepage0.FirstStartFlag) {
    eepage0.FirstStartFlag = 0;
    ee_write_page(0, &eepage0, sizeof(EEPage0_t));
  }

  /* finished */
  EEPROM_State_Data() = EE_STORE_SUCCESS;
}
